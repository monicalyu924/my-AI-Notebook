import { isNumericValue } from './lib/utils.mjs';

var TRAILING_SLASH_REGEXP = "(\\/\\d+)?";
var VALUE_REGEXP = "(-(?<v>.+?)" + TRAILING_SLASH_REGEXP + ")?";
function createSimpleHandler(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    byType = _ref.byType;
  var simpleHandler = function simpleHandler(memory, _ref2) {
    var _memory$target;
    var value = _ref2.v,
      target = _ref2.t;
    var type = byType && isNumericValue(value) ? "number" : "other";
    var mem = (_memory$target = memory[target]) != null ? _memory$target : memory[target] = {};
    // seen before
    if (mem[type]) return false;
    // never seen
    return mem[type] = true;
  };
  return simpleHandler;
}
function simpleRule(target, _temp2) {
  var _ref3 = _temp2 === void 0 ? {} : _temp2,
    byType = _ref3.byType;
  var regExp = "(?<t>" + target + ")" + VALUE_REGEXP + "$";
  return [regExp, createSimpleHandler({
    byType: byType
  })];
}
var CARDINAL_OVERRIDES = {
  t: ",y,tl,tr",
  r: ",x,tr,br",
  b: ",y,br,bl",
  l: ",x,bl,tl",
  x: "",
  y: "",
  s: "",
  e: "",
  ss: ",e,s",
  se: ",e,s",
  es: ",e,s",
  ee: ",e,s"
};
var CARDINAL_DIRECTIONS = /*#__PURE__*/Object.keys(CARDINAL_OVERRIDES).join("|") + "|tl|tr|br|bl";
function createCardinalHandler(_temp3) {
  var _ref4 = _temp3 === void 0 ? {} : _temp3,
    byType = _ref4.byType;
  var cardinalHandler = function cardinalHandler(memory, _ref5) {
    var _memory$direction, _memory$_, _memory$_$type, _memory$_2, _CARDINAL_OVERRIDES$d;
    var value = _ref5.v,
      _ref5$d = _ref5.d,
      direction = _ref5$d === void 0 ? "" : _ref5$d;
    var type = byType && isNumericValue(value) ? "number" : "other";
    var mem = (_memory$direction = memory[direction]) != null ? _memory$direction : memory[direction] = {};
    // seen before
    if (mem[type]) return false;
    // apply override
    var memOverriders = (_memory$_$type = (_memory$_ = (_memory$_2 = memory._) != null ? _memory$_2 : memory._ = {})[type]) != null ? _memory$_$type : _memory$_[type] = new Set();
    if ((_CARDINAL_OVERRIDES$d = CARDINAL_OVERRIDES[direction]) != null && _CARDINAL_OVERRIDES$d.split(",").some(function (dir) {
      return memOverriders.has(dir);
    })) return false;
    // remember overrider
    memOverriders.add(direction);
    // never seen
    mem[type] = true;
    return true;
  };
  return cardinalHandler;
}
function cardinalRule(target, _temp4) {
  var _ref6 = _temp4 === void 0 ? {} : _temp4,
    _ref6$dash = _ref6.dash,
    dash = _ref6$dash === void 0 ? true : _ref6$dash,
    byType = _ref6.byType;
  var _target = target + "(" + (dash ? "-" : "") + "(?<d>" + CARDINAL_DIRECTIONS + "))?";
  var regExp = "" + _target + VALUE_REGEXP + "$";
  return [regExp, createCardinalHandler({
    byType: byType
  })];
}
function cardinalRules(targets, options) {
  var _targets = targets.split("|");
  return _targets.map(function (target) {
    return cardinalRule(target, options);
  });
}
// unique rule
// -----------
function createUniqueHandler() {
  var uniqueHandler = function uniqueHandler(memory, groups) {
    var key = Object.entries(groups).find(function (x) {
      return x[1];
    })[0];
    return memory[key] ? false : memory[key] = true;
  };
  return uniqueHandler;
}
function uniqueRule(targets) {
  var regExp = "(" + targets.map(function (target, targetI) {
    return Array.isArray(target) ? target.slice(1).map(function (subtarget, subtargetI) {
      return "(?<i" + targetI + "_" + subtargetI + ">" + (target[0] + "-(" + subtarget + ")") + ")";
    }) : "(?<i" + targetI + ">" + target + ")";
  }).flat().join("|") + ")" + TRAILING_SLASH_REGEXP + "$";
  return [regExp, createUniqueHandler()];
}
// arbitrary rule
// --------------
function createArbitraryHandler() {
  var arbitraryHandler = function arbitraryHandler(memory, _ref7) {
    var _memory$property;
    var property = _ref7.p;
    var mem = (_memory$property = memory[property]) != null ? _memory$property : memory[property] = {};
    // seen before
    if (mem.done) return false;
    // never seen
    return mem.done = true;
  };
  return arbitraryHandler;
}
function arbitraryRule() {
  return ["\\[(?<p>.+?):.*\\]$", createArbitraryHandler()];
}
function createConflictHandler(targets) {
  var overridableMap = {};
  Object.entries(targets).forEach(function (_ref8) {
    var overridingUtility = _ref8[0],
      overridableUtilities = _ref8[1];
    return overridableUtilities.split("|").forEach(function (value) {
      var _overridableMap$value;
      (_overridableMap$value = overridableMap[value]) != null ? _overridableMap$value : overridableMap[value] = [];
      overridableMap[value].push(overridingUtility);
    });
  });
  var conflictHandler = function conflictHandler(memory, _ref9) {
    var utility = _ref9.u;
    // is overridable utility and overriding utility has been seen
    var skipClass = Boolean(utility in overridableMap && overridableMap[utility].some(function (u) {
      return memory[u];
    }));
    if (skipClass) return false;
    // is overriding utility
    if (utility in targets) memory[utility] = true;
    // continue evaluating other rules
    return "c";
  };
  return conflictHandler;
}
function conflictRule(targets) {
  var overridingUtilities = Object.keys(targets);
  var overridableUtilities = Object.values(targets).join("|").split("|");
  var matchingClasses = [].concat(overridingUtilities, overridableUtilities);
  var utility = "(?<u>" + matchingClasses.join("|") + ")";
  var regExp = "" + utility + VALUE_REGEXP + "$";
  return [regExp, createConflictHandler(targets)];
}

export { TRAILING_SLASH_REGEXP, VALUE_REGEXP, arbitraryRule, cardinalRule, cardinalRules, conflictRule, createArbitraryHandler, createCardinalHandler, createConflictHandler, createSimpleHandler, createUniqueHandler, simpleRule, uniqueRule };
//# sourceMappingURL=rules.mjs.map
