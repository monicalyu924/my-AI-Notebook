import { createLruCache } from './create-lru-cache.mjs';
import { normalizeContext } from './utils.mjs';

function createMerge(ruleSet, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    _ref$cacheSize = _ref.cacheSize,
    cacheSize = _ref$cacheSize === void 0 ? 500 : _ref$cacheSize,
    _ref$separator = _ref.separator,
    separator = _ref$separator === void 0 ? ":" : _ref$separator,
    prefix = _ref.prefix;
  var cache = createLruCache(cacheSize);
  var parsedRuleSet = ruleSet.map(function (_ref2) {
    var regExp = _ref2[0],
      handler = _ref2[1];
    return [new RegExp("^(?<c>.*" + separator + "!?|!?)?-?" + (prefix ? prefix + "-" : "") + regExp), handler];
  });
  function merge(className) {
    var cached = cache.get(className);
    if (cached !== undefined) return cached;
    var memoryStore = [];
    var classes = className.split(" ");
    var outputClasses = [];
    // - for each class from right to left
    for (var classI = classes.length - 1; classI >= 0; classI--) {
      var currentClass = classes[classI];
      var didNotMatchOrWasContinued = true;
      // - for each rule
      for (var ruleI = 0; ruleI < parsedRuleSet.length; ruleI++) {
        var rule = parsedRuleSet[ruleI];
        var regexp = rule[0];
        var match = currentClass.match(regexp);
        // - if class matches rule, execute it
        if (match) {
          var _groups$c, _memoryStore$ruleI, _memoryStore$ruleI$co, _ruleI, _memoryStore$_ruleI;
          didNotMatchOrWasContinued = false;
          var groups = match.groups;
          var context = normalizeContext((_groups$c = groups == null ? void 0 : groups.c) != null ? _groups$c : "", separator);
          var handler = rule[1];
          var memory = (_memoryStore$ruleI$co = (_memoryStore$ruleI = (_memoryStore$_ruleI = memoryStore[_ruleI = ruleI]) != null ? _memoryStore$_ruleI : memoryStore[_ruleI] = {})[context]) != null ? _memoryStore$ruleI$co : _memoryStore$ruleI[context] = {};
          var result = handler(memory, groups);
          var keepClass = result === true;
          var continueToNextRule = result === "c";
          if (keepClass) outputClasses.unshift(currentClass);
          // - finish with the class unless the rule says so
          if (!continueToNextRule) break;
          didNotMatchOrWasContinued = true;
        }
      }
      if (didNotMatchOrWasContinued) outputClasses.unshift(currentClass);
    }
    return cache.set(className, outputClasses.join(" "));
  }
  return merge;
}

export { createMerge };
//# sourceMappingURL=create-merge.mjs.map
