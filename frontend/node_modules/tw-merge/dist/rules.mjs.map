{"version":3,"file":"rules.mjs","sources":["../src/rules.ts"],"sourcesContent":["import { isNumericValue } from \"./lib/utils\";\n\nexport type Handler<T = any> = (\n  memory: T,\n  matches: NonNullable<RegExpMatchArray[\"groups\"]>\n) => boolean | \"c\"; // keep class | continue to next rule\n\nexport type Rule = [string, Handler];\nexport type RuleSet = Rule[];\n\nexport const TRAILING_SLASH_REGEXP = \"(\\\\/\\\\d+)?\";\nexport const VALUE_REGEXP = `(-(?<v>.+?)${TRAILING_SLASH_REGEXP})?`;\n\n// simple rule\n// -----------\n\nexport type SimpleHandlerOptions = { byType?: boolean };\n\nexport function createSimpleHandler({ byType }: SimpleHandlerOptions = {}) {\n  const simpleHandler: Handler<\n    Record<string, Partial<Record<\"number\" | \"other\", boolean>>>\n  > = (memory, { v: value, t: target }) => {\n    const type = byType && isNumericValue(value) ? \"number\" : \"other\";\n    const mem = (memory[target!] ??= {});\n\n    // seen before\n    if (mem[type]) return false;\n\n    // never seen\n    return (mem[type] = true);\n  };\n\n  return simpleHandler;\n}\n\nexport type SimpleRuleOptions = SimpleHandlerOptions;\n\nexport function simpleRule(\n  target: string,\n  { byType }: SimpleRuleOptions = {}\n): Rule {\n  const regExp = `(?<t>${target})${VALUE_REGEXP}$`;\n  return [regExp, createSimpleHandler({ byType })];\n}\n\n// cardinal rule\n// -------------\n\nexport type CardinalHandlerOptions = {\n  byType?: boolean;\n};\n\ntype Direction = string;\n\nconst CARDINAL_OVERRIDES: Record<string, string> = {\n  t: \",y,tl,tr\",\n  r: \",x,tr,br\",\n  b: \",y,br,bl\",\n  l: \",x,bl,tl\",\n  x: \"\",\n  y: \"\",\n  s: \"\",\n  e: \"\",\n  ss: \",e,s\",\n  se: \",e,s\",\n  es: \",e,s\",\n  ee: \",e,s\",\n};\nconst CARDINAL_DIRECTIONS =\n  Object.keys(CARDINAL_OVERRIDES).join(\"|\") + \"|tl|tr|br|bl\";\n\nexport function createCardinalHandler({ byType }: CardinalHandlerOptions = {}) {\n  const cardinalHandler: Handler<\n    Partial<Record<Direction, Partial<Record<\"number\" | \"other\", boolean>>>> & {\n      _?: Partial<Record<\"number\" | \"other\", Set<string>>>;\n    }\n  > = (memory, { v: value, d: direction = \"\" }) => {\n    const type = byType && isNumericValue(value) ? \"number\" : \"other\";\n    const mem = (memory[direction] ??= {});\n\n    // seen before\n    if (mem[type]) return false;\n\n    // apply override\n    const memOverriders = ((memory._ ??= {})[type] ??= new Set());\n    if (\n      CARDINAL_OVERRIDES[direction]\n        ?.split(\",\")\n        .some((dir) => memOverriders.has(dir))\n    )\n      return false;\n\n    // remember overrider\n    memOverriders.add(direction);\n\n    // never seen\n    mem[type] = true;\n    return true;\n  };\n\n  return cardinalHandler;\n}\n\nexport type CardinalRuleOptions = {\n  /**\n   * Whether the direction is dash-separated (e.g. `border-t-2`)\n   * @default true\n   */\n  dash?: boolean;\n} & CardinalHandlerOptions;\n\nexport function cardinalRule(\n  target: string,\n  { dash = true, byType }: CardinalRuleOptions = {}\n): Rule {\n  const _target = `${target}(${dash ? \"-\" : \"\"}(?<d>${CARDINAL_DIRECTIONS}))?`;\n  const regExp = `${_target}${VALUE_REGEXP}$`;\n  return [regExp, createCardinalHandler({ byType })];\n}\n\nexport function cardinalRules(targets: string, options?: CardinalRuleOptions) {\n  const _targets = targets.split(\"|\");\n  return _targets.map((target) => cardinalRule(target, options));\n}\n\n// unique rule\n// -----------\n\nexport function createUniqueHandler() {\n  const uniqueHandler: Handler<Record<string, boolean>> = (memory, groups) => {\n    const key = Object.entries(groups).find((x) => x[1])![0];\n    return memory[key] ? false : (memory[key] = true);\n  };\n  return uniqueHandler;\n}\n\nexport type UniqueRuleOptions = { prefix?: string; def?: boolean };\n\nexport function uniqueRule(targets: (string | string[])[]): Rule {\n  const regExp = `(${targets\n    .map((target, targetI) =>\n      Array.isArray(target)\n        ? target\n            .slice(1)\n            .map(\n              (subtarget, subtargetI) =>\n                `(?<i${targetI}_${subtargetI}>${`${target[0]}-(${subtarget})`})`\n            )\n        : `(?<i${targetI}>${target})`\n    )\n    .flat()\n    .join(\"|\")})${TRAILING_SLASH_REGEXP}$`;\n  return [regExp, createUniqueHandler()];\n}\n\n// arbitrary rule\n// --------------\n\nexport function createArbitraryHandler() {\n  const arbitraryHandler: Handler<Record<string, { done?: boolean }>> = (\n    memory,\n    { p: property }\n  ) => {\n    const mem = (memory[property!] ??= {});\n\n    // seen before\n    if (mem.done) return false;\n\n    // never seen\n    return (mem.done = true);\n  };\n\n  return arbitraryHandler;\n}\n\nexport function arbitraryRule(): Rule {\n  return [`\\\\[(?<p>.+?):.*\\\\]$`, createArbitraryHandler()];\n}\n\n// conflict rule\n// -------------\n\nexport type ConflictRuleTargets = Record<string, string>;\n\nexport function createConflictHandler(targets: ConflictRuleTargets) {\n  const overridableMap: Record<string, string[]> = {};\n  Object.entries(targets).forEach(([overridingUtility, overridableUtilities]) =>\n    overridableUtilities.split(\"|\").forEach((value) => {\n      overridableMap[value] ??= [];\n      overridableMap[value]!.push(overridingUtility);\n    })\n  );\n\n  const conflictHandler: Handler<Record<string, boolean>> = (\n    memory,\n    { u: utility }\n  ) => {\n    // is overridable utility and overriding utility has been seen\n    const skipClass = Boolean(\n      utility! in overridableMap &&\n        overridableMap[utility!]!.some((u) => memory[u])\n    );\n    if (skipClass) return false;\n\n    // is overriding utility\n    if (utility! in targets) memory[utility!] = true;\n\n    // continue evaluating other rules\n    return \"c\";\n  };\n\n  return conflictHandler;\n}\n\nexport function conflictRule(targets: ConflictRuleTargets): Rule {\n  const overridingUtilities = Object.keys(targets);\n  const overridableUtilities = Object.values(targets).join(\"|\").split(\"|\");\n  const matchingClasses = [...overridingUtilities, ...overridableUtilities];\n  const utility = `(?<u>${matchingClasses.join(\"|\")})`;\n  const regExp = `${utility}${VALUE_REGEXP}$`;\n  return [regExp, createConflictHandler(targets)];\n}\n"],"names":["TRAILING_SLASH_REGEXP","VALUE_REGEXP","createSimpleHandler","byType","simpleHandler","memory","value","v","target","t","type","isNumericValue","mem","simpleRule","regExp","CARDINAL_OVERRIDES","r","b","l","x","y","s","e","ss","se","es","ee","CARDINAL_DIRECTIONS","Object","keys","join","createCardinalHandler","cardinalHandler","d","direction","memOverriders","_","Set","split","some","dir","has","add","cardinalRule","dash","_target","cardinalRules","targets","options","_targets","map","createUniqueHandler","uniqueHandler","groups","key","entries","find","uniqueRule","targetI","Array","isArray","slice","subtarget","subtargetI","flat","createArbitraryHandler","arbitraryHandler","property","p","done","arbitraryRule","createConflictHandler","overridableMap","forEach","overridingUtility","overridableUtilities","push","conflictHandler","utility","u","skipClass","Boolean","conflictRule","overridingUtilities","values","matchingClasses"],"mappings":"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"}